use bevy_ecs::prelude::*;
use log::debug;
use rand::Rng;
use rand_distr::StandardNormal;

use crate::component::{Attribute, Skill, Stats};

const STANDARD_DEVIATION: f32 = 5.0;

/// Modifications to be applied to a check.
#[derive(Clone, Copy, Debug)]
pub struct CheckModifiers {
    /// Any value to be added to the value of the stat before the check.
    pub value_modifier: Option<f32>,
    /// Any value to be added to the result of the check before determining success.
    pub result_modifier: Option<f32>,
}

impl CheckModifiers {
    /// Creates modifiers that do nothing.
    pub fn none() -> CheckModifiers {
        CheckModifiers {
            value_modifier: None,
            result_modifier: None,
        }
    }

    /// Creates modifiers that change the value of the stat before the check.
    pub fn modify_value(value_modifier: f32) -> CheckModifiers {
        CheckModifiers {
            value_modifier: Some(value_modifier),
            result_modifier: None,
        }
    }

    /// Creates modifiers that change the result of the check before determining success.
    pub fn modify_result(result_modifier: f32) -> CheckModifiers {
        CheckModifiers {
            value_modifier: None,
            result_modifier: Some(result_modifier),
        }
    }
}

/// Generates a total for a check using the provided stat value.
///
/// The total is generated by sampling from a normal distribution centered on the stat value.
fn roll_normal(stat_name: &str, raw_stat_value: f32, modifiers: CheckModifiers) -> u16 {
    // this will generate a float from a normal distribution centered around 0 with a standard deviation of 1
    let raw_total: f32 = rand::thread_rng().sample(StandardNormal);

    let modified_stat_value = if let Some(value_modifier) = modifiers.value_modifier {
        raw_stat_value + value_modifier
    } else {
        raw_stat_value
    };

    // this transforms the value so it's like it came from a normal distribution with a mean of the stat value and a different standard deviation
    let float_total = (raw_total * STANDARD_DEVIATION) + modified_stat_value;
    let modified_float_total = if let Some(result_modifier) = modifiers.result_modifier {
        float_total + result_modifier
    } else {
        float_total
    };

    let total = modified_float_total.round().clamp(0.0, u16::MAX.into()) as u16;

    debug!(
        "{} roll: value {} (raw {}), total {} (raw {})",
        stat_name, modified_stat_value, raw_stat_value, total, modified_float_total
    );

    total
}

/// The difficulty of a check.
#[derive(Clone, Copy, Debug)]
pub struct CheckDifficulty {
    /// The minimum result required to pass the check.
    target: u16,
    /// If the result is below this, it will be considered an extreme failure.
    extreme_failure_threshold: u16,
    /// If the result is above this, it will be considered an extreme success.
    extreme_success_threshold: u16,
}

impl CheckDifficulty {
    /// Creates a difficulty with the provided target.
    pub fn new(target: u16) -> CheckDifficulty {
        let extreme_failure_threshold = if STANDARD_DEVIATION as u16 > target {
            0
        } else {
            target - STANDARD_DEVIATION as u16
        };

        CheckDifficulty {
            target,
            extreme_failure_threshold,
            extreme_success_threshold: target + STANDARD_DEVIATION as u16,
        }
    }

    /// For trivially easy checks.
    pub fn trivial() -> CheckDifficulty {
        CheckDifficulty {
            target: 1,
            extreme_failure_threshold: 0,
            extreme_success_threshold: 2,
        }
    }

    /// For easy checks.
    pub fn easy() -> CheckDifficulty {
        CheckDifficulty {
            target: 4,
            extreme_failure_threshold: 2,
            extreme_success_threshold: 8,
        }
    }

    /// For moderately difficult checks.
    pub fn moderate() -> CheckDifficulty {
        CheckDifficulty {
            target: 7,
            extreme_failure_threshold: 3,
            extreme_success_threshold: 11,
        }
    }

    /// For difficult checks.
    pub fn hard() -> CheckDifficulty {
        CheckDifficulty {
            target: 10,
            extreme_failure_threshold: 6,
            extreme_success_threshold: 20,
        }
    }

    /// For very difficult checks.
    pub fn very_hard() -> CheckDifficulty {
        CheckDifficulty {
            target: 13,
            extreme_failure_threshold: 6,
            extreme_success_threshold: 26,
        }
    }

    /// For extremely difficult checks.
    pub fn extreme() -> CheckDifficulty {
        CheckDifficulty {
            target: 16,
            extreme_failure_threshold: 8,
            extreme_success_threshold: 32,
        }
    }
}

/// Performs a check with the provided difficulty.
fn check(
    stat_name: &str,
    stat_value: f32,
    modifiers: CheckModifiers,
    difficulty: CheckDifficulty,
) -> CheckResult {
    let total = roll_normal(stat_name, stat_value, modifiers);

    if total < difficulty.extreme_failure_threshold {
        CheckResult::ExtremeFailure
    } else if total < difficulty.target {
        CheckResult::Failure
    } else if total > difficulty.extreme_success_threshold {
        CheckResult::ExtremeSuccess
    } else {
        CheckResult::Success
    }
}

/// Identifies a participant in a versus check.
pub enum VsParticipantType {
    /// The first participant.
    First,
    /// The second participant.
    Second,
}

/// Describes parameters for a versus check.
pub struct VsCheckParams {
    /// Which participant wins if both entities have the same total
    pub winner_on_tie: VsParticipantType,
    /// If the results' difference is greater than this, it will be considered an extreme failure for one entity and an extreme success for the other.
    pub extreme_result_difference: u16,
}

/// Performs a check of two stats against each other.
fn check_vs(
    stat_1_name: &str,
    stat_1_value: f32,
    modifiers_1: CheckModifiers,
    stat_2_name: &str,
    stat_2_value: f32,
    modifiers_2: CheckModifiers,
    params: VsCheckParams,
) -> (CheckResult, CheckResult) {
    let total_1 = roll_normal(stat_1_name, stat_1_value, modifiers_1);
    let total_2 = roll_normal(stat_2_name, stat_2_value, modifiers_2);

    if total_1.abs_diff(total_2) > params.extreme_result_difference {
        if total_1 > total_2 {
            (CheckResult::ExtremeSuccess, CheckResult::ExtremeFailure)
        } else {
            (CheckResult::ExtremeFailure, CheckResult::ExtremeSuccess)
        }
    } else if total_1 > total_2 {
        (CheckResult::Success, CheckResult::Failure)
    } else if total_2 > total_1 {
        (CheckResult::Failure, CheckResult::Success)
    } else {
        match params.winner_on_tie {
            VsParticipantType::First => (CheckResult::Success, CheckResult::Failure),
            VsParticipantType::Second => (CheckResult::Failure, CheckResult::Success),
        }
    }
}

/// The result of performing a check.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum CheckResult {
    /// The total didn't even come close.
    ExtremeFailure,
    /// The total was too low, but not by a lot.
    Failure,
    /// The total was high enough, but not super high.
    Success,
    /// The total was way higher than needed.
    ExtremeSuccess,
}

impl CheckResult {
    /// Determines whether the check succeeded at all.
    pub fn succeeded(&self) -> bool {
        match self {
            CheckResult::Success | CheckResult::ExtremeSuccess => true,
            CheckResult::Failure | CheckResult::ExtremeFailure => false,
        }
    }
}

impl Stats {
    /// Performs a check against an attribute on the provided entity.
    pub fn check_attribute(
        entity: Entity,
        attribute: &Attribute,
        modifiers: CheckModifiers,
        difficulty: CheckDifficulty,
        world: &World,
    ) -> CheckResult {
        if let Some(stats) = world.get::<Stats>(entity) {
            check(
                &format!("{attribute:?}"),
                f32::from(stats.attributes.get(attribute)),
                modifiers,
                difficulty,
            )
        } else {
            // the entity doesn't have stats, so they fail all checks
            CheckResult::ExtremeFailure
        }
    }

    /// Performs checks for two entities' attributes against each other.
    pub fn check_attribute_vs(
        entity_1: Entity,
        attribute_1: &Attribute,
        modifiers_1: CheckModifiers,
        entity_2: Entity,
        attribute_2: &Attribute,
        modifiers_2: CheckModifiers,
        params: VsCheckParams,
        world: &World,
    ) -> (CheckResult, CheckResult) {
        todo!() //TODO
    }

    /// Performs a check against a skill on the provided entity.
    pub fn check_skill(
        entity: Entity,
        skill: &Skill,
        modifiers: CheckModifiers,
        difficulty: CheckDifficulty,
        world: &World,
    ) -> CheckResult {
        if let Some(stats) = world.get::<Stats>(entity) {
            check(
                &format!("{skill:?}"),
                stats.get_skill_total(skill, world),
                modifiers,
                difficulty,
            )
        } else {
            // the entity doesn't have stats, so they fail all checks
            CheckResult::ExtremeFailure
        }
    }

    /// Performs checks for two entities' skills against each other.
    pub fn check_skill_vs(
        entity_1: Entity,
        skill_1: &Skill,
        modifiers_1: CheckModifiers,
        entity_2: Entity,
        skill_2: &Skill,
        modifiers_2: CheckModifiers,
        params: VsCheckParams,
        world: &World,
    ) -> (CheckResult, CheckResult) {
        todo!() //TODO
    }
}
